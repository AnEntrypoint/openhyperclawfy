Objective            
 Integrate the X402 system (per https://x402.gitbook.io/x402) into Hyperfy in a clean, optional, client-side way that plugs into the existing camera  
 and postprocessing stack, exposes a stable API to apps, and includes a working example. Preserve existing camera examples and prim examples. 
 Assumptions and open questions to confirm with you         
 • Which parts of X402 do you want? (camera post FX, DOF model, color/tone mapping, motion/handheld sway, presets, etc.)   
 • Is X402 an npm package or documentation-driven recipes? If npm, what package name/version? If docs-only, we’ll vendor minimal modules needed under 
 src/core/libs/x402.            
 • Target platforms: Web + XR. If XR, we’ll auto-disable heavy effects in XR.       
             
 High-level approach            
 • Add an optional X402 client system that manages X402 effects/presets and bridges them to Hyperfy’s CameraManager + ClientGraphics. It returns 
 “effects” that can be inserted into the postprocessing chain, or runs its own composer per active Camera node (matching current design).   
 • Add prefs + world API so apps can toggle/use X402 without direct DOM/web API access.      
 • Extend existing camera example to demo X402 presets toggling.         
             
 Concrete steps (ordered)            
 1. Read X402 docs and decide install method          
 • If npm package: add dependency and import paths. If not, vendor minimal modules under src/core/libs/x402/.     
 • Identify X402 features to wire: DOF, tone mapping/LUT, bloom variant, chromatic aberration, camera sway, presets.    
 2. Create a new client system X402System          
 • New file: src/core/systems/X402.js           
 • Responsibilities:            
 • Initialize X402 runtime (create effects, presets, params) on client only.      
 • Listen to world.camera-changed to rebind effects to the active camera.       
 • Provide a stable API: enable/disable, applyPreset(name), setParams({ … }), getEffects() (for ClientGraphics), getState() (for diagnostics). 
 • Respect prefs.x402Enabled and update when prefs change.        
 • Skeleton (for reference; to be implemented later):         
             
             
 1 export class X402 extends System {         
 2 constructor(world) { super(world); this.enabled = false; this.effects = []; this.presets = {}; }     
 3 async init() { /* client-only guards, load X402 assets if any */ }        
 4 start() { this.world.on('camera-changed', this.onCameraChanged); this.world.prefs.on('change', this.onPrefsChange); }    
 5 onCameraChanged = cam => { if (!this.enabled) return; /* rebuild/rebind effects to cam.camera */ }    
 6 onPrefsChange = changes => { if (changes.x402Enabled) this.setEnabled(changes.x402Enabled.value); }     
 7 setEnabled(v) { this.enabled = !!v; /* create/destroy effects */ }        
 8 applyPreset(name) { /* map preset -> effect params, update */ }        
 9 setParams(params) { /* update effect uniforms */ }        
 10 getEffects() { return this.enabled ? this.effects : []; }         
 11 getState() { return { enabled: this.enabled, presets: Object.keys(this.presets) }; }      
 12 }            
             
 3. Register X402 system in client and viewer worlds          
 • Edit src/core/createClientWorld.js: add import + registration after cameraControls.      
             
             
  src/core/createClientWorld.js lines 1-5          
             
 1 import { World } from './World.js'         
 2 // ...            
 3 import { ClientCameraControls } from './systems/ClientCameraControls'       
 4 import { CameraManager } from './systems/CameraManager'        
 5 // Add: import { X402 } from './systems/X402'         
             
             
  src/core/createClientWorld.js lines 27-33           
             
 27 export function createClientWorld() {         
 28 const world = new World()           
 29 // ...             
 30 world.register('cameraControls', ClientCameraControls)         
 31 world.register('cameraManager', CameraManager)         
 32 // Add: world.register('x402', X402)          
 33 world.register('network', ClientNetwork)         
             
 • Edit src/core/createViewerWorld.js similarly.         
             
             
  src/core/createViewerWorld.js lines 15-24           
             
 15 export function createViewerWorld() {         
 16 const world = new World()           
 17 world.register('client', Client)         
 18 world.register('prefs', ClientPrefs)          
 19 world.register('loader', ClientLoader)         
 20 world.register('controls', ClientControls)          
 21 world.register('cameraControls', ClientCameraControls)         
 22 world.register('cameraManager', CameraManager)         
 23 // Add: world.register('x402', X402)          
 24 world.register('graphics', ClientGraphics)          
             
 • Add corresponding import at the top of createViewerWorld.js.        
 4. Extend ClientPrefs with X402 flags/params and setters        
 • Initialize default prefs and persist them.         
             
             
  src/core/systems/ClientPrefs.js lines 35-43         
             
 35  // Camera settings          
 36  this.dofEnabled = isBoolean(data.dofEnabled) ? data.dofEnabled : false       
 37  // ...           
 38  this.focalLength = isNumber(data.focalLength) ? data.focalLength : 24      
 39  this.showHelpers = isBoolean(data.showHelpers) ? data.showHelpers : false       
 40  // Add: X402           
 41  this.x402Enabled = isBoolean(data.x402Enabled) ? data.x402Enabled : false       
 42  this.x402Preset = data.x402Preset || null // e.g., 'cinematic', 'portrait', etc.      
 43  this.x402Params = data.x402Params || null // freeform key-value bag        
             
             
  src/core/systems/ClientPrefs.js lines 86-94         
             
 86  storage.set('prefs', {           
 87  // ... existing fields ...           
 88  zoomSpeed: this.zoomSpeed,           
 89  // Add:           
 90  x402Enabled: this.x402Enabled,          
 91  x402Preset: this.x402Preset,         
 92  x402Params: this.x402Params,         
 93  v: this.v,           
 94  })            
             
 • Add setters (near other setters):          
 • setX402Enabled(value), setX402Preset(value), setX402Params(value)        
 5. Expose world API methods for apps to drive X402         
 • Edit src/core/systems/Apps.js worldMethods block to forward to world.x402 when present.     
             
             
  src/core/systems/Apps.js lines 58-83          
             
 58  // Camera manager helpers for apps         
 59  activateDefaultCamera(entity) {         
 60 // ...            
 61  },             
 62  setActiveCameraById(entity, id) {          
 63 // ...            
 64  },             
 65  // Add: X402 bridge (client-only; no-ops on server)        
 66  x402Enable(entity, enabled) {           
 67 if (!this.world.x402) return false         
 68 this.world.prefs.setX402Enabled(!!enabled)         
 69 this.world.x402.setEnabled(!!enabled)         
 70 return true           
 71  },             
 72  x402ApplyPreset(entity, name) {         
 73 if (!this.world.x402) return false         
 74 this.world.prefs.setX402Preset(name)          
 75 this.world.x402.applyPreset(name)          
 76 return true           
 77  },             
 78  x402SetParams(entity, params) {         
 79 if (!this.world.x402) return false         
 80 this.world.prefs.setX402Params(params)        
 81 this.world.x402.setParams(params)          
 82 return true           
 83  },             
             
 6. Wire X402 into ClientGraphics postprocessing chain        
 • In init() after creating this.effectPass, conditionally append X402 effects if enabled. Also update on prefs change.    
             
             
  src/core/systems/ClientGraphics.js lines 102-106         
             
  102  this.effectPass = new EffectPass(this.world.camera)        
  103  this.updatePostProcessingEffects()          
  104  this.composer.addPass(this.effectPass)         
  105  this.world.prefs.on('change', this.onPrefsChange)         
  106  // Add: if (this.world.x402?.enabled) merge X402 effects into effectPass here or let X402’s per-camera composer render when active  
             
 • In render(): prefer the active camera node’s composer if X402 is managing its own composer for the active camera.    
             
             
  src/core/systems/ClientGraphics.js lines 169-177         
             
  169  if (this.renderer.xr.isPresenting || !this.usePostprocessing) {       
  170  // ...            
  171  } else if (activeCameraNode?.composer) {          
  172  // Use the camera node's composer if it has one         
  173  activeCameraNode.composer.render()         
  174  } else {            
  175  // Fall back to the default composer         
  176  this.composer.render()          
  177  }             
             
 • Update updatePostProcessingEffects() to optionally include this.world.x402.getEffects() if enabled.    
 7. Update ClientCameraControls (compatibility only)          
 • Ensure no conflicts when X402 is enabled. When prefs.x402Enabled is true, we’ll:       
 • Leave camera distance/ADS logic as-is, but avoid duplicating DOF/bokeh if X402 overrides DOF. A simple rule in ClientCameraControls.update: if 
  world.prefs.x402Enabled, skip setting DOF uniforms; allow focal length changes to still work.     
 8. Provide a working example app under examples         
 • Extend existing examples/camera-control-system.js to add a toggle that turns X402 on/off and applies presets. Keep camera-dof-bridge.js and all 
 prim* examples untouched.            
 • Add: props fields “useX402” and “x402Preset” with a small UI (toggle + dropdown), then call world.x402* API on config changes.  
 9. Optional: add commands for admins (similar to cam.*) for X402        
 • If window is defined and user is admin, expose window.x402. helpers: enable(), preset(name), set(params), state(). They will call world.x402..  
 10. Build & test            
 • If npm: npm i x402 (or library name per docs) and import in X402 system. If vendor: place code under src/core/libs/x402 and import from there.  
 • Run npm run dev and validate:           
 • Default camera path is unchanged when X402 disabled.        
 • Toggle on X402, switch cameras (examples and default). Ensure effects follow active camera.     
 • Verify dofFocusDistance and focal length interactions still function.       
 • Ensure XR: effects disabled (or toned down) in XR presentation.        
 • Performance: measure frame rate with stats pane.         
 11. Edge cases & considerations           
 • Server builds: X402 system must be client-only guarded (typeof window !== 'undefined').     
 • Missing package: If X402 is not available as npm, vendor carefully and ensure ESM compatibility with esbuild.     
 • Postprocessing conflicts: Avoid duplicating DOF/bloom between ClientGraphics and X402; decide ownership (prefer X402 when enabled). Provide a 
 migration flag.           
 • CameraManager transitions: during transitions, X402 should switch target camera or temporarily disable to avoid ghosting.    
 • Persistence: prefs persist state so X402 stays enabled across reloads.        
 • Helpers: ensure camera helpers still visible when X402 is active.        
 • Restore deleted example: if examples/camera-dof-bridge.js was unintentionally deleted, recover it from git history before shipping.  
             
 Files to create             
 • src/core/systems/X402.js (new)          
             
 Files to modify             
 • src/core/createClientWorld.js (import + register X402)        
 • src/core/createViewerWorld.js (import + register X402)        
 • src/core/systems/ClientPrefs.js (add x402 prefs + setters + persistence)       
 • src/core/systems/Apps.js (expose world API for X402 to apps)        
 • src/core/systems/ClientGraphics.js (conditionally add/integrate X402 effects)       
 • examples/camera-control-system.js (add UI + call world.x402 API)         
 • optional: restore examples/camera-dof-bridge.js if deletion not intended       
             
 Dependencies/order             
 1. Implement X402 system skeleton.           
 2. Register in worlds.            
 3. Add prefs + setters; wire worldMethods in Apps.         
 4. Integrate into ClientGraphics (effect pass composition).        
 5. Extend example with UI + handlers.          
 6. Install/bring X402 lib and assets (LUTs, etc.).         
 7. Manual verification and performance checks.          
             
 Roll-back plan            
 • X402 system is optional and can be disabled via prefs.x402Enabled; removing the registration lines cleanly detaches it.  